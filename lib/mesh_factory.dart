import 'dart:ui';
import 'package:flutter_angle/flutter_angle.dart';
import 'package:fsg/float32_array_filler.dart';
import 'package:fsg/polyline.dart';
import 'package:fsg/triangle_mesh.dart';
import 'package:fsg/util.dart';
import 'package:fsg/vertex_buffer.dart';
import 'package:vector_math/vector_math_64.dart';

/// A utility class with static methods to create complex [TriangleMesh] objects
/// or populate [VertexBuffer] objects from geometry.
class MeshFactory {
  // Private constructor to prevent instantiation of this utility class.
  MeshFactory._();

  /// Fills a [vbo] with tessellated geometry from a list of [faces].
  ///
  /// This method is designed to create a drawable representation of a solid
  /// by converting its [Polyline] faces into textured triangles.
  static void fromSolidFaces(VertexBuffer vbo, List<Polyline> faces) {
    // Safely calculate the exact number of triangles needed.
    int triangleCount = 0;
    for (var face in faces) {
      if (face.length > 2) {
        triangleCount += face.length - 2;
      }
    }

    int vertexCount = triangleCount * 3;
    Float32Array? vertexTextureArray = vbo.requestBuffer(vertexCount);
    if (vertexTextureArray != null) {
      Float32ArrayFiller filler = Float32ArrayFiller(vertexTextureArray);
      for (var face in faces) {
        _addTexturedTriFan(filler, face, true);
      }
    }
    vbo.setActiveVertexCount(vertexCount);
  }

  /// Creates a [TriangleMesh] by tessellating a list of [faces].
  ///
  /// This is useful for generating geometry for CPU-side operations like picking
  /// or physics calculations.
  static TriangleMesh fromFaces(List<Polyline> faces) {
    // Safely calculate the exact number of triangles needed.
    int triangleCount = 0;
    for (var face in faces) {
      // A convex polygon with N vertices tessellates into N-2 triangles.
      if (face.length > 2) {
        triangleCount += face.length - 2;
      }
    }

    if (triangleCount == 0) {
      return TriangleMesh.empty();
    }

    final mesh = TriangleMesh(triangleCount);

    int currentTriangle = 0;
    for (var face in faces) {
      currentTriangle = _addOutlineAsTriFan(mesh, face, currentTriangle);
    }
    mesh.recomputeBounds();
    return mesh;
  }

  /// Fills a [vbo] by tessellating a list of [outlines] with a solid [color].
  static void tessellateColorOutlines(
      VertexBuffer vbo, List<Polyline> outlines, Color color) {
    _tessellate(vbo, outlines, (filler, outline) {
      _addColorTriFan(filler, outline, color);
    });
  }

  /// Fills a [vbo] by tessellating a list of [outlines] with texture coordinates.
  /// If [generateNormals] is true, normals will be included in the vertex data.
  static void tessellateOutlines(
      VertexBuffer vbo, List<Polyline> outlines, bool generateNormals) {
    _tessellate(vbo, outlines, (filler, outline) {
      _addTexturedTriFan(filler, outline, generateNormals);
    });
  }

  /// Generic helper to tessellate a list of outlines into a vertex buffer.
  /// The specific vertex data is generated by the provided [addFunction].
  static void _tessellate(VertexBuffer vbo, List<Polyline> outlines,
      Function(Float32ArrayFiller, Polyline) addFunction) {
    int triangleCount = 0;
    for (var outline in outlines) {
      if (outline.length > 2) {
        triangleCount += (outline.length - 2);
      }
    }

    int newVertexCount = triangleCount * 3;
    final buffer = vbo.requestBuffer(newVertexCount);

    if (buffer != null) {
      final filler = Float32ArrayFiller(buffer);
      for (var outline in outlines) {
        if (outline.length > 2) {
          addFunction(filler, outline);
        }
      }
    }
    vbo.setActiveVertexCount(newVertexCount);
  }

  /// Private helper to add a colored triangle fan for a single outline.
  static void _addColorTriFan(
      Float32ArrayFiller filler, Polyline outline, Color color) {
    int numTris = outline.length - 2;
    Vector3 v0 = outline.getVector3(0);
    for (int j = 0; j < numTris; j++) {
      Vector3 v1 = outline.getVector3(j + 1);
      Vector3 v2 = outline.getVector3(j + 2);
      filler.addV3C4(v0, color);
      filler.addV3C4(v1, color);
      filler.addV3C4(v2, color);
    }
  }

  /// Private helper to add a textured triangle fan for a single outline.
  static void _addTexturedTriFan(
      Float32ArrayFiller filler, Polyline outline, bool generateNormals) {
    int numTris = outline.length - 2;
    Vector3 v0 = outline.getVector3(0);
    Vector3 normal = Vector3.zero();

    if (outline.planeIsValid) {
      normal = outline.normal!;
    }

    final bounds = outline.getBounds2D();
    double w = bounds.max.x - bounds.min.x;
    double h = bounds.max.y - bounds.min.y;
    double x = bounds.min.x;
    double y = bounds.min.y;

    for (int j = 0; j < numTris; j++) {
      Vector3 v1 = outline.getVector3(j + 1);
      Vector3 v2 = outline.getVector3(j + 2);

      List<Vector2> texCoord = computeTexCoords(v0, v1, v2, x, y, w, h);

      if (generateNormals) {
        filler.addV3T2N3(v0, texCoord[0], normal);
        filler.addV3T2N3(v1, texCoord[1], normal);
        filler.addV3T2N3(v2, texCoord[2], normal);
      } else {
        filler.addV3V2(v0, texCoord[0]);
        filler.addV3V2(v1, texCoord[1]);
        filler.addV3V2(v2, texCoord[2]);
      }
    }
  }

  /// Creates a new [TriangleMesh] by extruding a list of [outlines] by a [depth] vector.
  /// This generates top, bottom, and side faces to create a closed 3D shape.
  static TriangleMesh extrude(List<Polyline> outlines, Vector3 depth) {
    if (outlines.isEmpty) {
      return TriangleMesh.empty();
    }

    // Calculate total triangles needed for top/bottom caps and side walls.
    int topCount = 0;
    for (var outline in outlines) {
      if (outline.length > 2) {
        topCount += (outline.length - 2);
      }
    }

    int sideCount = 0;
    for (var outline in outlines) {
      sideCount += (outline.length) * 2; // Each edge of the outline becomes 2 triangles.
    }

    int extrudedTriangleCount = topCount * 2 + sideCount;
    if (extrudedTriangleCount == 0) {
      return TriangleMesh.empty();
    }

    TriangleMesh result = TriangleMesh(extrudedTriangleCount);
    int currentTriangle = 0;

    // Add the top faces.
    for (var outline in outlines) {
      if (outline.planeIsValid) {
        currentTriangle =
            _addOutlineAsTriFan(result, outline, currentTriangle);
      }
    }

    // Add the bottom faces (reversed winding order).
    for (var outline in outlines) {
      if (outline.planeIsValid) {
        Vector3 bottomNormal = -outline.normal!;
        currentTriangle = _addOutlineAsReverseTriFan(
            result, outline, bottomNormal, currentTriangle, depth);
      }
    }

    // Add the side walls.
    for (var outline in outlines) {
      for (int i = 0; i < outline.length; i++) {
        currentTriangle =
            _makeSideFromEdge(result, outline, i, currentTriangle, depth);
      }
    }

    result.recomputeBounds();

    return result;
  }

  /// Helper to generate the top cap of an extruded mesh for a CPU-side [TriangleMesh].
  static int _addOutlineAsTriFan(
      TriangleMesh mesh, Polyline outline, int currentTriangle) {
    if (!outline.planeIsValid) return currentTriangle;
    int numTris = outline.length - 2;

    final bounds = outline.getBounds2D();
    double w = bounds.max.x - bounds.min.x;
    double h = bounds.max.y - bounds.min.y;
    double x = bounds.min.x;
    double y = bounds.min.y;

    Vector3 v0 = outline.getVector3(0);
    for (int i = 0; i < numTris; i++) {
      Vector3 v1 = outline.getVector3(i + 2);
      Vector3 v2 = outline.getVector3(i + 1);

      List<Vector2> texCoord = computeTexCoords(v0, v1, v2, x, y, w, h);

      currentTriangle = mesh.addTriangle(
          v0, v1, v2, outline.normal!, texCoord, currentTriangle);
    }
    return currentTriangle;
  }

  /// Helper to generate the bottom cap of an extruded mesh with reversed winding.
  static int _addOutlineAsReverseTriFan(TriangleMesh mesh, Polyline outline,
      Vector3 normal, int currentTriangle, Vector3 depth) {
    if (!outline.planeIsValid) return currentTriangle;
    int numTris = outline.length - 2;

    final bounds = outline.getBounds2D();
    double w = bounds.max.x - bounds.min.x;
    double h = bounds.max.y - bounds.min.y;
    double x = bounds.min.x;
    double y = bounds.min.y;

    Vector3 v0 = outline.getVector3(0) + depth;
    for (int i = 0; i < numTris; i++) {
      Vector3 v1 = outline.getVector3(i + 2) + depth;
      Vector3 v2 = outline.getVector3(i + 1) + depth;

      List<Vector2> texCoord = computeTexCoords(v2, v1, v0, x, y, w, h);

      currentTriangle =
          mesh.addTriangle(v2, v1, v0, normal, texCoord, currentTriangle);
    }
    return currentTriangle;
  }

  /// Helper to generate the two triangles that form a side wall from one edge of an outline.
  static int _makeSideFromEdge(TriangleMesh mesh, Polyline outline, int index,
      int currentTriangle, Vector3 depth) {
    Vector3 p1 = outline.getVector3(index % outline.length);
    Vector3 p2 = outline.getVector3((index + 1) % outline.length);
    Vector3 normal = (p2 - p1).cross(depth).normalized();

    Vector3 p1z = p1 + depth;
    Vector3 p2z = p2 + depth;

    // TODO: Calculate correct texture coordinates for sides.
    List<Vector2> texCoord = [Vector2.zero(), Vector2(1, 0), Vector2(1, 1)];
    currentTriangle =
        mesh.addTriangle(p1, p2, p2z, normal, texCoord, currentTriangle);

    texCoord = [Vector2.zero(), Vector2(1, 1), Vector2(0, 1)];
    currentTriangle =
        mesh.addTriangle(p1, p2z, p1z, normal, texCoord, currentTriangle);

    return currentTriangle;
  }
}
